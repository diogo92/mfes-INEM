class Hospital -- Represents a Health Unit
	types
		public HospitalLevel = nat;
		public BraceletColor = <RED>|<YELLOW>|<GREEN>;
		--public Location = Position;
		public Location = token; -- Location of a Health Unit
		public PatientCapacity = nat; -- Max patient capacity
		public MedicsInHospital = nat;
		--public Patient = Patient;
		public Patient :: braceletColor: BraceletColor; 
	  public Medic = token; 
	  --public Vehicle = Transport;
		public Vehicle = token;
		public HospitalAssignment = inmap Medic to Patient; 
		public EmergencyAssignment = inmap Vehicle to Patient; 
		
	instance variables
		public static capacity: PatientCapacity :=0;
		public numOfMedics: nat :=0;
		public numOfVehicles: nat :=0;
		public static level: HospitalLevel :=0;
		public static waitingList: seq of Patient :=[]; -- Patients waiting to be assigned; there cannot be more patients than the hospital capacity
		public static availableMedics: seq of Medic :=[]; -- Medics available in the hospital
		public static unavailableMedics: seq of Medic :=[]; -- Medics assigned to an appointment with a patient
		public static availableVehicles: seq of Vehicle :=[]; -- Vehicles available in the hospital to provide emergency assistance
		public static unavailableVehicles: seq of Vehicle :=[]; -- Vehicles that are providing assistance to an emergencys
		public static hospitalAssignments: seq of HospitalAssignment :=[]; -- Assignments from  doctors to patients
		public static emergencyAssignments: seq of EmergencyAssignment :=[]; -- Vehicle assistances to emergencies
	operations
	
	
		public Hospital: nat1 * nat1 * nat1 * nat1 ==> Hospital
			Hospital(patientCap,hLevel,medics,vehicles) == (
				dcl i:nat;
				capacity:= patientCap;
				level:=hLevel;
					i:=1;
					while i<=medics do(
						addMedic();
							i:=i+1;
							numOfMedics := numOfMedics+1;
							);
					i:=1;
					while i<=vehicles do(
						addVehicle();
							i:=i+1;
							numOfVehicles := numOfVehicles+1;
							);
				return self;
			);
		
		-- Adds a medic to the list
		public addMedic: () ==>()
			addMedic()== (
				dcl m:Medic;
				availableMedics:=availableMedics^[m];
			);
		
		-- Adds a vehicle to the list
		public addVehicle:()==>()
			addVehicle()== (
				dcl v:Vehicle;
				availableVehicles:=availableVehicles^[v];
			);
		-- Assigns a medic, if avaliable
		public static assignMedicToPatient: Patient * Medic ==> (HospitalAssignment)
		 assignMedicToPatient(p,m) == (
			
			dcl auxAssignment: HospitalAssignment := {|->};
			auxAssignment := (auxAssignment :-> {p}) munion {m |-> p};
			waitingList := remove[Patient](p,waitingList);
			availableMedics := remove[Medic](m,availableMedics);
			unavailableMedics := unavailableMedics^[m];
			hospitalAssignments := hospitalAssignments^[auxAssignment];
			return auxAssignment;
		)
		pre
			--Medic is available and in medics list
			elemExists[Medic](availableMedics,m)
			
			and -- Patient in patients list
			elemExists[Patient](waitingList,p)
	
		post
			-- Assigned medic removed from available list, and respective patient removed from waiting list
			not elemExists[Medic](availableMedics,m) 
			and elemExists[Medic](unavailableMedics,m)
			and not elemExists[Patient](waitingList,p)
			
			-- Assignment is in hospital assignment list
			and elemExists[HospitalAssignment](hospitalAssignments,{m|->p})
		;
		
		
		-- Put a patient in the waiting list, freeing the vehicle that did the transportation
		public putPatientInWaitingList: Patient * Vehicle * EmergencyAssignment ==>()
		 putPatientInWaitingList(p,v,assignment) ==(
			unavailableVehicles := remove[Vehicle](v,unavailableVehicles);
			availableVehicles := availableVehicles^[v];
			waitingList := insertInOrder(waitingList,p);
			emergencyAssignments := remove[EmergencyAssignment](assignment,emergencyAssignments);
		)
		pre
			
			-- Assigned emergency where patient was transported is in list
			
			assignment={v|->p} and assignment in set elems emergencyAssignments
			
		post
		-- Patient must be in the waiting list
			p in set elems waitingList and elemExists[Vehicle](availableVehicles,v)
		-- Emergency not in assignment list
			and not elemExists[EmergencyAssignment](emergencyAssignments,assignment)
		;
		
		
		-- A medic ends its apointment with a patient, freeing him
		public freeMedic: Medic * Patient * HospitalAssignment ==>()
		 freeMedic(m,p, assignment) ==(
			unavailableMedics := remove[Medic](m,unavailableMedics);
			availableMedics := availableMedics^[m];
			hospitalAssignments := remove[HospitalAssignment](assignment,hospitalAssignments);
		)
		pre
			-- Medic must be the one in the assigned apointment
			assignment={m|->p} 
			-- Hospital assignment in list
			and assignment in set elems hospitalAssignments
		post
			-- Medic is free
			m in set elems availableMedics
			-- Assignment not in list
			and not elemExists[HospitalAssignment](hospitalAssignments,assignment)
		;
	
	-- Assign a vehicle to attend an emergency
	public attendEmergency: Patient * Vehicle ==>()
	attendEmergency(p,v)==
	(
		dcl auxAssignment: EmergencyAssignment := {|->};
			auxAssignment := (auxAssignment :-> {p}) munion {v |-> p};
			availableVehicles := remove[Vehicle](v,availableVehicles);
			unavailableVehicles := unavailableVehicles^[v];
			emergencyAssignments := emergencyAssignments^[auxAssignment];
	)
	
	pre
		-- Bringing a patient must not overflow the capacity of the hospital
			len waitingList < capacity and
		-- Vehicle is available for emergency
		elemExists[Vehicle](availableVehicles,v) and not elemExists[Vehicle](unavailableVehicles,v)
	post
		-- Vehicle is not available for other emergencies
		elemExists[Vehicle](unavailableVehicles,v) and not elemExists[Vehicle](availableVehicles,v)
		-- Emergency Assignment in list
		and elemExists[EmergencyAssignment](emergencyAssignments,{v|->p})
		;

functions

		public insertInOrder(s:seq of Patient,p:Patient) res: seq of Patient ==
			if(p.braceletColor = <RED>) then(
				if(not exists i in set inds s & s(i).braceletColor=<RED>)
					then([p]^s)
					else(
						insertInOrder(tl s,p)
					)
			)
			else if(p.braceletColor = <YELLOW>) then(
				if(not exists i in set inds s & s(i).braceletColor=<RED> and not exists j in set inds s & s(j).braceletColor=<YELLOW>)
					then([p]^s)
					else(
						insertInOrder(tl s,p)
					)
			)
			else(s^[p])
		;
		-- Checks if element is in list
		public elemExists[@T](s:seq of @T,m:@T) res: bool ==
			 m in set elems s;
			 
		public remove[@T](e: @T, s: seq of @T) res: seq of @T ==
    	[s(i) | i in set inds s & s(i) <> e];
	
end Hospital